s1
len(s1)
length(s1)
size(s1)
cols(s1)
ncol(s1)
size(s1[1])
length(s1[1])
length(s1[1,1])
dim(s1)
v = s1[1]
v
v = s1[[1]]
v
length(v)
source('~/.active-rstudio-document')
s1
s2
source('~/.active-rstudio-document')
s2 = strsplit(seq2, split="", fixex=T)
s2
seq1 = "AGACTGACTG";
seq2 = "ACTGTGCAT";
# split those sequences into individual letters
s1 = strsplit(seq1, split="", fixed=T);
s2 = strsplit(seq2, split="", fixex=T);
se2
seq2
source('~/.active-rstudio-document')
s2
s1
source('~/.active-rstudio-document')
M
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
M
s1
c(s1, "{}")
names(M) = c(s1, "{}")
M
names(M)
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
M = as.table(matrix(0, l2+1, l1+1)); # use a table, because you can then assign row + column names
names(M)
M
names(M) <- c(s1, "{}")
M
names(M)
attributes(M) = c(s1, "{}")
attributes(M) = as.list(c(s1, "{}"))
colnames
colnames(M)
source('~/.active-rstudio-document')
M
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
M
(l1-1):1
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
M
source('~/.active-rstudio-document')
M
r = 1
c = 1
match.score = (s1[c]==s2[r])
match.score
c = 2
match.score = (s1[c]==s2[r])
match.score
match.score + 4
c = 1
match.score
match.score = (s1[c]==s2[r])
match.score + 4
as.integer(T)
source('~/Math337Package/Resources/Unit04DynamicProgramming/SequenceAlignment.R')
source('~/.active-rstudio-document')
M
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/Math337Package/Resources/Unit04DynamicProgramming/SequenceAlignment.R')
clear
clear()
cls()
source('~/.active-rstudio-document')
profit_x8
dpois(50, 10)
dpois(51, 10)
dem = 0:150;
p_dem = dpois(dem, 10)
p_dem
dem = 0:(5*mean_dem8);
p_dem = dpois(dem, 10)
mean_dem8 = 10;
dem = 0:(5*mean_dem8);
p_dem = dpois(dem, 10)
p_dem
dem
sold = min(dem, x8)
x8 = 10
sold = min(dem, x8)
sold
pmin(dem, 0)
pmin(dem, x8)
sold = min(dem, x8)
sold
sold = pmin(dem, x8)
sold
x8-dem
pmax(x8-dem, 0)
profit_dem =  20 * sold - 5 * unsold - 3*unmet_dem);
profit_dem =  20 * sold - 5 * unsold - 3*unmet_dem;
sold = pmin(dem, x8);
unsold = pmax(x8-dem, 0);
unmet_dem = pmax(dem-x8, 0);
profit_dem =  20 * sold - 5 * unsold - 3*unmet_dem;
profit_dem
profit_dem * p_dem
profit_dem * p_dem
sum(profit_dem * p_dem)
x8
source('~/.active-rstudio-document')
profit_x8
profit_x8
max_stock = 10 + 1 #can have 0 axles
lambda = 5.1             #mean axles used per day
stock = as.vector(c(10, 8, 8, 10, 7, 9, 9, 9, 10, 10, 10)) #sum of s_n and a_n. The amount we start with on day n+1.
P = matrix(0, max_stock, max_stock)
for (i in 1:max_stock) {
for (j in 1:max_stock) {
P[i, j] = dpois(max(stock[i]-(j-1), 0), lambda)
}
}
e = eigen(t(P))
probs = Re(e$vectors[,1])/sum(Re(e$vectors[,1]))
pob
probs
P
maxS = 12 # 1 to 12 people can be assigned to last component
# Component 4
M4 = matrix(0, maxS, maxS-1)
f4_star = matrix(0, maxS, 1);
x4_star = matrix(0, maxS, 1);
for (s in 1:maxS){
for (x in 1:(maxS-1)){
if (x <= (s-1)) { # only spend up to # staff remaining
M4[s, x] = prob(x, 1.0, 4)
}
}
# Find AN optimal value for each s (might be duplicates)
f4_star[s] = max(M4[s,])
x4_star[s] = which.max(M4[s,])
}
f4 = max(f4_star)
x4 = max(x4_star)
maxS = 12 # 1 to 13 people can be assigned to 3rd component
# Component 3
M3 = matrix(0, maxS, maxS-1)
f3_star = matrix(0, maxS, 1);
x3_star = matrix(0, maxS, 1);
for (s in 1:maxS){
for (x in 1:(maxS-1)){
if (x <= (s-1)) { # need (# spent + 1 more for component 4) components left
s_next = (s - x) + 1;
M3[s, x] = prob(x, 0.5, 2)*f4_star[s_next]
}
}
# Find AN optimal value for each s (might be duplicates)
f3_star[s] = max(M3[s,])
x3_star[s] = which.max(M3[s,])
}
f3 = max(f3_star)
x3 = max(x3_star)
maxS = 12 # 1 to 14 people can be assigned to second component
# Component 2
M2 = matrix(0, maxS, maxS-1)
f2_star = matrix(0, maxS, 1);
x2_star = matrix(0, maxS, 1);
for (s in 1:maxS){
for (x in 1:(maxS-1)){
if (x <= (s-1)) { # need (# spent + 1 more for component 3) components left
s_next = (s - x) + 1;
M2[s, x] = prob(x, 0.1, 2)*f3_star[s_next]
}
}
# Find AN optimal value for each s (might be duplicates)
f2_star[s] = max(M2[s,])
x2_star[s] = which.max(M2[s,])
}
f2 = max(f2_star)
x2 = max(x2_star)
maxS = 12 # 1 to 15 people can be assigned to first component
# Component 1
M1 = matrix(0, maxS, maxS-1)
f1_star = matrix(0, maxS, 1);
x1_star = matrix(0, maxS, 1);
for (s in 1:maxS){
for (x in 1:(maxS-1)){
if (x <= (s-1)) { # need (# spent + 1 more for component 2) components left
s_next = (s - x) + 1;
M1[s, x] = prob(x, 0.2, 5)*f2_star[s_next]
}
}
# Find AN optimal value for each s (might be duplicates)
f1_star[s] = max(M1[s,])
x1_star[s] = which.max(M1[s,])
}
f1 = max(f1_star)
x1 = max(x1_star)
x1
x1_star
f1_star
prob <- function(N, k, d) {
return(exp(k*(N-d))/(1+exp(k*(N-d))))
}
maxS = 12 # 1 to 12 people can be assigned to last component
# Component 4
M4 = matrix(0, maxS, maxS-1)
f4_star = matrix(0, maxS, 1);
x4_star = matrix(0, maxS, 1);
for (s in 1:maxS){
for (x in 1:(maxS-1)){
if (x <= (s-1)) { # only spend up to # staff remaining
M4[s, x] = prob(x, 1.0, 4)
}
}
# Find AN optimal value for each s (might be duplicates)
f4_star[s] = max(M4[s,])
x4_star[s] = which.max(M4[s,])
}
f4 = max(f4_star)
x4 = max(x4_star)
maxS = 12 # 1 to 13 people can be assigned to 3rd component
# Component 3
M3 = matrix(0, maxS, maxS-1)
f3_star = matrix(0, maxS, 1);
x3_star = matrix(0, maxS, 1);
for (s in 1:maxS){
for (x in 1:(maxS-1)){
if (x <= (s-1)) { # need (# spent + 1 more for component 4) components left
s_next = (s - x) + 1;
M3[s, x] = prob(x, 0.5, 2)*f4_star[s_next]
}
}
# Find AN optimal value for each s (might be duplicates)
f3_star[s] = max(M3[s,])
x3_star[s] = which.max(M3[s,])
}
f3 = max(f3_star)
x3 = max(x3_star)
maxS = 12 # 1 to 14 people can be assigned to second component
# Component 2
M2 = matrix(0, maxS, maxS-1)
f2_star = matrix(0, maxS, 1);
x2_star = matrix(0, maxS, 1);
for (s in 1:maxS){
for (x in 1:(maxS-1)){
if (x <= (s-1)) { # need (# spent + 1 more for component 3) components left
s_next = (s - x) + 1;
M2[s, x] = prob(x, 0.1, 2)*f3_star[s_next]
}
}
# Find AN optimal value for each s (might be duplicates)
f2_star[s] = max(M2[s,])
x2_star[s] = which.max(M2[s,])
}
f2 = max(f2_star)
x2 = max(x2_star)
maxS = 12 # 1 to 15 people can be assigned to first component
# Component 1
M1 = matrix(0, maxS, maxS-1)
f1_star = matrix(0, maxS, 1);
x1_star = matrix(0, maxS, 1);
for (s in 1:maxS){
for (x in 1:(maxS-1)){
if (x <= (s-1)) { # need (# spent + 1 more for component 2) components left
s_next = (s - x) + 1;
M1[s, x] = prob(x, 0.2, 5)*f2_star[s_next]
}
}
# Find AN optimal value for each s (might be duplicates)
f1_star[s] = max(M1[s,])
x1_star[s] = which.max(M1[s,])
}
f1 = max(f1_star)
x1 = max(x1_star)
x1_star
f4_star
f3_star
maxS = 12 # 1 to 13 people can be assigned to 3rd component
# Component 3
M3 = matrix(0, maxS, maxS-1)
f3_star = matrix(0, maxS, 1);
x3_star = matrix(0, maxS, 1);
for (s in 1:maxS){
for (x in 1:(maxS-1)){
if (x <= (s-1)) { # need (# spent + 1 more for component 4) components left
#      s_next = (s - x) + 1;
s_next = (s - x);
M3[s, x] = prob(x, 0.5, 2)*f4_star[s_next]
}
}
# Find AN optimal value for each s (might be duplicates)
f3_star[s] = max(M3[s,])
x3_star[s] = which.max(M3[s,])
}
f3 = max(f3_star)
x3 = max(x3_star)
f3_star
f3
M3
f4_star
# intial P-matrix
P = as.matrix(
rbind(
cbind(0.8, 0.2,   0,   0,   0),
cbind(  0, 0.5, 0.5,   0,   0),
cbind(  0,   0, 0.7, 0.3,   0),
cbind(  0,   0,   0, 0.9, 0.1),
cbind(  1,   0,   0,   0,   0)
)
)
e = eigen(t(P))
probs = Re(e$vectors[,1])/sum(Re(e$vectors[,1]))
expected_payout = 0
p = 200
while (expected_payout < 23.4375) {
p = p + 0.01
expected_payout = probs[5] * p
}
### OLD
best_actions = (1,0,0,0,2)
expected_payouts = (0,0,0,0,70)
payouts = c(0, 20, 30, 50, 70)
actions = c(1, 1, 1, 1, 2)
while(TRUE) {
for (s in 2:4) {
max_payout = 0
for (a in 1:2) {
actions[s] = a
#Update Payout
pays = c(0,0,0,0,0)
for (i in 1:5)
pays[i] = ifelse(actions[i] == 2, payouts[i], 0)
# expected payout
avg_payouts = NULL
for (i in 1:5)
avg_payouts = c(avg_payouts, pays[i]*probs[i])
avg_payout = sum(avg_payouts)
# Keep action tha optimized E[avg. payout]
if (avg_payout > max_payout) {
print(s)
best_actions[s] = a
expected_payouts[s] = avg_payout
max_payout = avg_payout
}
} # end actions
} # end states
actions = best_actions
cat(paste(sprintf("\tPayoutss: ")), expected_payouts)
cat(sprintf("\n"))
} #while
# Policy iteration
# intial P-matrix
P = as.matrix(
rbind(
cbind(0.8, 0.2,   0,   0,   0),
cbind(  0, 0.5, 0.5,   0,   0),
cbind(  0,   0, 0.7, 0.3,   0),
cbind(  0,   0,   0, 0.9, 0.1),
cbind(  1,   0,   0,   0,   0)
)
)
e = eigen(t(P))
probs = Re(e$vectors[,1])/sum(Re(e$vectors[,1]))
expected_payout = 0
p = 200
while (expected_payout < 23.4375) {
p = p + 0.01
expected_payout = probs[5] * p
}
expected_payout
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
x = seq(0, 3, length.out=100)
f = x * exp(-2*x)
plot(x, f)
x = 0
x1 = x0 - x * exp(-2*x)/((1-2*x)*exp(-2*x)
x = 0
x1 = x0 - x * exp(-2*x)/((1-2*x)*exp(-2*x))
expected_payout
x = 0
x1 = x0 - x * exp(-2*x)/((1-2*x)*exp(-2*x))
x1 = x - x * exp(-2*x)/((1-2*x)*exp(-2*x))
x1
x1 = x - (x * exp(-2*x)-0.1)/((1-2*x)*exp(-2*x))
x1
x = 0
x1 = x - (x * exp(-2*x)-0.1)/((1-2*x)*exp(-2*x))
x = x1
x2 = x - (x * exp(-2*x)-0.1)/((1-2*x)*exp(-2*x))
x2
x = 0
x1 = x - (x * exp(-2*x)-0.1)/((1-2*x)*exp(-2*x))
x = x1
x2 = x - (x * exp(-2*x)-0.1)/((1-2*x)*exp(-2*x))
x = x2
fx = x * exp(-2*x) - 0.1
fx
x = seq(0, 5, length.out=100)
f = 0.5 *(4-x/2)*(8*x-x^2)
plot(x, f)
x = seq(2, 3, length.out=100)
f = 0.5 *(4-x/2)*(8*x-x^2)
plot(x, f)
source('~/Contract/2014_StatsLabs/Integrity/EvaluatePairs.R')
source('D:/Users/aableson/Documents/Dropbox/StatsProject/Labs/Lab11_MigraineCase_AA/GenerateData.R')
source('D:/Users/aableson/Documents/Dropbox/StatsProject/Labs/Lab11_MigraineCase_AA/GenerateData.R')
t = seq(0, 2*pi)
t = seq(pi/2, 3*pi/2, length.out=9)
x = cos(t)*0.6
x
y = sin(t)*2+2
y
x = cos(t)*0.4
y = sin(t)*1.5+1.5
rbind(x,y)
t(rbind(x,y))
sprintf("%.2f", t(rbind(x,y)))
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
s = c(10, 10, 13, 15, 21, 22, 24, 24, 26, 31, 38, 39, 40, 41)
mean(s)
median(s)
x = c(0, 1, 2, 3, 4)
p = c(.2, .45, .2, .13, .02)
p * x
sum(p * x)
p = 0.4 * 48
s = sqrt(48*.4*.6)
dnorm
pnorm(17/48, p, s)
qnorm(17/48, p, s)
s = sqrt(48*.4*.6)
pnorm(17/48, 0.4, s)
17/48
s
pnorm(17, 0.4*48, s)
s
qnorm(17, 0.4*48, s)
pnorm(0.4*48, 0.4*48, s)
pnorm(17, 0.4*48, s)
.4*48
s
(17-19.2)/3.39
pnorm(16.5, 0.4*48, s)
log(15.5/17)
log(10)
log(exp(1))
log(7/17)/log(15.5/17)
2*sqrt(8)*.2*25  + 8*(-0.011)
2*sqrt(8)*(-0.011)*25  + 8*0.2
sqrt(8)/50*0.2
2*sqrt(8)*(-0.01131)*25  + 8*0.2
r = c(0, 5, 4.5, 3, 0)
co = c(1, 4, 2, 4, 1)
r*co
sum(r*co)
1050*.75
x = seq(-4, 4)
y = 3*x^2 - 2*x+5
plot(x, y)
y = 3*x^2 - 2*x-5
plot(x, y)
dot(c(1,3), c(4,5))
sum( c(1,3) * c(4, 5))
sum( c(-2, 3, 1) * c(2, 1, 4))
norm_vec <- function(x) sqrt(sum(x^2))
norm_vec(c(-2, 3, 1) )
norm_vec(c(-2, 3, 1)  )
norm_vec(c(2, 1, 4))
acos(3/(3.7*4.6))
3/(3.7*46)
3/(3.7*4.6)
cos(pi/2)
cos(pi/2 + pi/3)
4 * cos(pi/2 + pi/3)
sqrt(3)/2
cos(pi/3)
4 * cos(5*pi/6)
4 * sqrt(3)/2
setwd("~/Webwork/IntroStats/Module01/Testing")
source('~/Webwork/IntroStats/Module01/Testing/load_csv_datasets.R')
source('~/Webwork/IntroStats/Module01/Testing/load_csv_datasets.R')
source('~/Webwork/IntroStats/Module01/Testing/load_csv_datasets.R')
MyData
names(MyData)
MyData$Plant
MyData$Treatment
MyData$C02Concentration
MyData$CO2Concentration
MyData = read.csv(file.choose(), colClasses=c('factor', 'factor', 'numeric', 'numeric'))
MyData$CO2Concentration
source('~/Webwork/IntroStats/Module01/Testing/load_csv_datasets.R')
