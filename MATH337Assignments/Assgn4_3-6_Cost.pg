
## DESCRIPTION
## Operations Research / Linear Algebra
## ENDDESCRIPTION

## KEYWORDS('steady state', 'eigenvalues' 'eigenvectors')
## Tagged by aableson

## DBsubject('Linear Algebra')
## DBchapter('Matrices')
## DBsection('Eigenvalues')
## Date('')
## Author('')
## Institution('Queens')
## TitleText1('')
## EditionText1('')
## AuthorText1('')
## Section1('')
## Problem1('')

DOCUMENT();        # This should be the first executable line in the problem.
loadMacros(
        "PGbasicmacros.pl",
        "PGchoicemacros.pl",
        "PGanswermacros.pl",
        "PGgraphmacros.pl",
        "PGmatrixmacros.pl",
	"parserPopUp.pl",
	"MathObjects.pl",
        );
 
TEXT(beginproblem());    
Context("Numeric");
Context()->flags->set(tolerance=>.01);
$showPartialCorrectAnswers = 1;

# Verify that we agree on the cost matrix; totals and constituents  

# Generated by MATH_337_2012/Assignments/Assignment04/Assignment04.R
$C_unmet = Matrix->new_from_array_ref([[0,0,0,0,0,0,0],[50,0,0,0,0,0,0],[100,50,0,0,0,0,0],[150,100,50,0,0,0,0],[200,150,100,50,0,0,0],[250,200,150,100,50,0,0],[300,250,200,150,100,50,0],[350,300,250,200,150,100,50],[400,350,300,250,200,150,100],[450,400,350,300,250,200,150],[500,450,400,350,300,250,200],[550,500,450,400,350,300,250],[600,550,500,450,400,350,300]]);
$C_inventory = Matrix->new_from_array_ref([[0,4,8,12,16,20,24],[0,0,4,8,12,16,20],[0,0,0,4,8,12,16],[0,0,0,0,4,8,12],[0,0,0,0,0,4,8],[0,0,0,0,0,0,4],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0]]);
$C_restock = Matrix->new_from_array_ref([[160,135,110,0,0,0,0],[160,160,135,110,0,0,0],[160,160,160,135,110,0,0],[160,160,160,160,135,110,0],[160,160,160,160,160,135,110],[160,160,160,160,160,160,135],[160,160,160,160,160,160,160],[160,160,160,160,160,160,160],[160,160,160,160,160,160,160],[160,160,160,160,160,160,160],[160,160,160,160,160,160,160],[160,160,160,160,160,160,160],[160,160,160,160,160,160,160]]);
$C_total = Matrix->new_from_array_ref([[160,139,118,12,16,20,24],[235,160,139,118,12,16,20],[310,235,160,139,118,12,16],[385,310,235,160,139,118,12],[460,385,310,235,160,139,118],[535,460,385,310,235,160,139],[610,535,460,385,310,235,160],[685,610,535,460,385,310,235],[760,685,610,535,460,385,310],[835,760,685,610,535,460,385],[910,835,760,685,610,535,460],[985,910,835,760,685,610,535],[1060,985,910,835,760,685,610]]);

# Decide on the random demand 
$demand = random(1, 5);

$s = 3;
$S = 6;
@states = ();
@ans_bar1 = ();
@ans_bar2 = ();
@ans_bar3 = ();
for ($i = 0; $i <= $S; $i++){
  push(@states, $i);
  push(@ans_bar1, ans_rule(6));
}
for ($i = 0; $i <= $S; $i++){
  push(@ans_bar2, ans_rule(6));
}
for ($i = 0; $i <= $S; $i++){
  push(@ans_bar3, ans_rule(6));
}

# Define the C_restock answer table
$table_1_start = begintable($S+1);
$table_1_row1  = row( " \(X_t\)", @states);
$table_1_row2  = row( "\(D_t = $demand\) ", @ans_bar1);
$table_1_end   = endtable();

# Define the C_inventory answer table
$table_2_start = begintable($S+1);
$table_2_row1  = row( " \(X_t\)", @states);
$table_2_row2  = row( "\(D_t = $demand\) ", @ans_bar2);
$table_2_end   = endtable();

# Define the C_unmet answer table
$table_3_start = begintable($S+1);
$table_3_row1  = row( " \(X_t\)", @states);
$table_3_row2  = row( "\(D_t = $demand\) ", @ans_bar3);
$table_3_end   = endtable();

# Build the correct answer vectors

@c_1 = ();
@c_2 = ();
@c_3 = ();
for ($i = 0; $i <= $S; $i++) {
  $v = $C_restock->element($demand+1, $i+1);
  push(@c_1, Compute("$v"));
  $v = $C_inventory->element($demand+1, $i+1);
  push(@c_2, Compute("$v"));
  $v = $C_unmet->element($demand+1, $i+1);
  push(@c_3, Compute("$v"));
}
BEGIN_TEXT 

In the inventory model, there are three costs (restocking, inventory and  missed sales).  These costs are variable, but can be determined for a given week if we know the demand and original state, \(D_t\) and \(X_t\) respectively.

$PAR

Based on the cost formulas provided in the background document, 
and $BBOLD using a $s/$S (s/S) restocking strategy$EBOLD 
complete the following tables: 

$PAR
Cost of $BBOLD restocking$EBOLD.
$table_1_start
$table_1_row1
$table_1_row2
$table_1_end

$PAR
Cost of $BBOLD inventory$EBOLD.
$table_2_start
$table_2_row1
$table_2_row2
$table_2_end

$PAR
Cost of $BBOLD missed sales$EBOLD.
$table_3_start
$table_3_row1
$table_3_row2
$table_3_end


END_TEXT

foreach $f (@c_1) {
  ANS( $f->cmp());
}
foreach $f (@c_2) {
  ANS( $f->cmp());
}
foreach $f (@c_3) {
  ANS( $f->cmp());
}


BEGIN_SOLUTION

$PAR $BBOLD Restocking cost $EBOLD
$BR Look at the value of \(X\) minus the demand.
<ul>
<li> If the result is less than $s, you will restock; if not, you believe post-demand inventory is sufficient (at least s=$s) and you will not re-order this week.
<li> The number restocked is at most $S, since you can't have fewer than zero items after your sales.
</ul>

$PAR $BBOLD Inventory costs$EBOLD 
$BR

Remember that inventory is charged
on $BBOLD post$EBOLD-demand inventory; subtract the demand away from
the state.

$PAR $BBOLD Missed sales costs $EBOLD
$BR
You only miss sales when the demand is greater than the current state/inventory level.  The amount by which the demand exceeds the current inventory is the number of missed sales.



END_SOLUTION


ENDDOCUMENT();       # This should be the last executable line in the problem.
